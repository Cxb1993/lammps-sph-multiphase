/* eq. (26), (27), (28) in Hu2006 */

load("gentran");
load("~/src/maxima-main/share/contrib/gentran/lspc.lisp");
gentranlang('c);

/*
["xx", "yy", "zz", "xy", "xz", "yz"];
*/

%tensor_idx_list%: [[1,1], [2,2], [3,3], [1,2], [1,3], [2,3]]$
extend_to_3d(P):= if length(P)=3 then P else addrow(addcol(P, [0, 0]), [0, 0, 0]);
fix_dim(P):= if length(P)=3 and %d%=2 then submatrix(3, P, 3) else P;

unpack_tensor(P):= block([S: extend_to_3d(P)], local(S), maplist(lambda([el], local(el), S[el[1], el[2]]), %tensor_idx_list%))$
pack_tensor(L):= block([P: zeromatrix(3, 3)], local(P, L, %tensor_idx_list%), 
  for i thru length(%tensor_idx_list%) do (arraymake('P, %tensor_idx_list%[i]) :: L[i], arraymake('P, reverse(%tensor_idx_list%[i])) :: L[i]),
  P)$

%d%: 3;
I: ident(%d%);

c_v : makelist(cg[k],  k, 0, %d%-1);
P_t: alpha * 1/'c_abs * (1/%d% * I * c_abs^2 - transpose(c_v) . c_v);
P_t: fullratsimp(P_t);

P_l: unpack_tensor(P_t);
c_abs: sqrt(c_v . c_v);
gentran(c_abs : eval(c_abs)) $
for i thru 6 do gentran(surface_stress[eval(i-1)] : eval(P_l[i])) $

eij_v: makelist(eij[k], k, 0, %d%-1) $
Pi_l:  makelist(Pi[k], k, 0, 6) $
Pi_t : pack_tensor(Pi_l) $
Pi_t : fix_dim(Pi_t) $

Pj_l:  makelist(Pj[k], k, 0, 6) $
Pj_t : pack_tensor(Pj_l) $
Pj_t : fix_dim(Pj_t) $

ai   : fullratsimp(1/mi * wfd * eij_v . (Pi_t/sigmai^2 + Pj_t/sigmaj^2)) $
fi   : mi*ai $

for i thru %d% do gentran( f[eval(i)] : eval(fi[1][i]) ) $

/*
e_v: makelist(e[k], k, d);
e_v . P;
*/
